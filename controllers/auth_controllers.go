// controllers/auth_controller.go
package controllers

import (
	"MyTransactAPP/config"
	"MyTransactAPP/models"
	"MyTransactAPP/utils"
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
	"github.com/o1egl/paseto"
	"github.com/sirupsen/logrus"
	"golang.org/x/crypto/bcrypt"
	// "gorm.io/gorm/utils"
)

// RegisterUser
// @Summary Register a new user with company profile
// @Description Register a new user along with their company profile
// @Tags auth
// @Accept  json
// @Produce  json
// @Param input body utils.RegisterUserRequest true "User registration details"
// @Success 200 {string} string "User registered successfully"
// @Failure 400 {string} string "Invalid request payload"
// @Router /auth/register [post]
func RegisterUser(c *gin.Context) {
	var req utils.RegisterUserRequest
	registerLogger := config.Log.WithFields(logrus.Fields{
		"API handler": "RegisterUser",
		"payload":     req,
	})

	if err := c.ShouldBindJSON(&req); err != nil {
		registerLogger.Error("Invalid Payload")
		utils.JSONResponse(c, http.StatusBadRequest, "Please provide valid payload", gin.H{"error": err.Error()})
		return
	}

	// validate password
	if req.Password != req.ConfirmPassword {
		utils.JSONResponse(c, http.StatusBadRequest, "Please enter valid payload", gin.H{"error": "password should match"})
	}

	// hash the password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
	if err != nil {
		utils.JSONResponse(c, http.StatusInternalServerError, "something went wrong", gin.H{"error": "Password encryption failed"})
		return
	}

	// Create user record
	newUser := models.User{
		FirstName: req.FirstName,
		LastName:  req.LastName,
		Email:     req.Email,
		Password:  string(hashedPassword),
	}
	//commit user to db
	if err := config.DB.Create(&newUser).Error; err != nil {
		registerLogger.Error("Failed to create user")
		utils.JSONResponse(c, http.StatusInternalServerError, "Failed to create user", gin.H{"error": err.Error()})
		return
	}

	// Create company profile record
	newCompany := models.CompanyProfile{
		UserID:      newUser.ID, // Assuming ID is auto-generated by GORM
		CompanyName: req.CompanyName,
	}
	// commit company to db
	config.DB.Create(&newCompany)
	registerLogger.Infof("Company created successfully with name : %v", req.CompanyName)

	//send the welcome email
	if err := utils.SendWelcomeEmail(newUser); err != nil {
		registerLogger.Infof("Failed to send welcome email: %v", err)
	}

	utils.JSONResponse(c, http.StatusOK, "User registration was successful", gin.H{"message": "User registered successfully"})
}

// Login godoc
// @Summary Log in a user
// @Description Authenticate a user and return a JWT token
// @Tags auth
// @Accept  json
// @Produce  json
// @Param auth body utils.AuthInput true "User credentials"
// @Success 200 {string} string "User registered successfully"
// @Failure 400 {string} string "Invalid request payload"
// @Failure 401 {string} string "Invalid credentials"
// @Failure 500 {string} string "Failed to generate token"
// @Router /auth/login [post]
func Login(c *gin.Context) {
	var input utils.AuthInput
	if err := c.ShouldBindJSON(&input); err != nil {
		utils.JSONResponse(c, http.StatusBadRequest, "Please provide valid payload", gin.H{"error": err.Error()})
		return
	}
	loginLogger := config.Log.WithFields(logrus.Fields{
		"API handler": "loginUser",
		"payload":     input,
	})

	var user models.User
	if err := config.DB.Where("email = ?", input.Email).First(&user).Error; err != nil {
		loginLogger.Error("Invalid user/ doesn't exist")
		utils.JSONResponse(c, http.StatusUnauthorized, "Please provide valid payload", gin.H{"error": "Invalid credentials"})
		return
	}

	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(input.Password)); err != nil {
		loginLogger.Error("Invalid password not able to decrypt")
		utils.JSONResponse(c, http.StatusUnauthorized, "Please provide valid payload", gin.H{"error": "Invalid credentials"})
		return
	}

	// Convert user ID to string if user.ID is of type uint
	userIDStr := strconv.FormatUint(uint64(user.ID), 10)

	token, err := utils.GenerateToken(userIDStr)
	if err != nil {
		loginLogger.Error("Failed to generate token")
		utils.JSONResponse(c, http.StatusInternalServerError, "Failed to generate token", gin.H{"error": err.Error()})
		return
	}

	loginLogger.Info("User successfully logged in")
	utils.JSONResponse(c, http.StatusOK, "Login successful", gin.H{"token": token})
}

// Logout godoc
// @Summary Logout user
// @Description Invalidate the current user's token
// @Tags auth
// @Accept json
// @Produce json
// @Success 200 {string} string "User logged out successfully"
// @Failure 401 {string} string "Unauthorized"
// @Router /auth/logout [post]
func Logout(c *gin.Context) {
	logoutLogger := config.Log.WithFields(logrus.Fields{
		"API handler": "Logout",
	})

	// Get token from authorization header
	authHeader := c.GetHeader("Authorization")
	if authHeader == "" {
		utils.JSONResponse(c, http.StatusUnauthorized, "Unauthorized", gin.H{"error": "Authorization header is required"})
		return
	}

	tokenString := utils.ExtractToken(authHeader)
	if tokenString == "" {
		utils.JSONResponse(c, http.StatusUnauthorized, "Unauthorized", gin.H{"error": "Invalid token format"})
		return
	}

	// Verify and decrypt token
	var jsonToken paseto.JSONToken
	var footer string

	err := paseto.NewV2().Decrypt(tokenString, utils.GetPasetoSecretKey(), &jsonToken, &footer)
	if err != nil {
		logoutLogger.Error("Invalid token")
		utils.JSONResponse(c, http.StatusUnauthorized, "Unauthorized", gin.H{"error": "Invalid token"})
		return
	}

	// Perform logout actions if needed (e.g., invalidate token on the server side)
	// Example: Clearing cookies or tokens
	c.SetCookie("token", "", -1, "/", "", false, true)
	logoutLogger.Info("User logged out successfully")
	utils.JSONResponse(c, http.StatusOK, "User logged out successfully", gin.H{"message": "User logged out successfully"})
}
